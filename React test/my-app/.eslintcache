[{"D:\\Documents\\Javascript\\React test\\my-app\\src\\index.js":"1"},{"size":22085,"mtime":1609465164734,"results":"2","hashOfConfig":"3"},{"filePath":"4","messages":"5","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"6"},"1ox5jh2","D:\\Documents\\Javascript\\React test\\my-app\\src\\index.js",["7","8","9","10","11","12"],"import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"./index.css\";\r\n\r\nconst DEFAULT_COLUMNS = 7;\r\nconst DEFAULT_ROWS = 6;\r\nconst DEFAULT_SEQ = 4;\r\n\r\nconst MAX_SIZE = 20;\r\nconst MIN_SIZE = 3;\r\nconst EMPTY = 0;\r\nconst WHITE = 1;\r\nconst BLACK = -100;\r\nconst WHITE_WIN = 10000;\r\nconst BLACK_WIN = -10000;\r\nconst DRAW = 0;\r\nconst ONGOING = -1;\r\n\r\nclass Board {\r\n\trows;\r\n\tcols;\r\n\twinSequence;\r\n\twhiteMoves;\r\n\ttotalMoves;\r\n\tboard;\r\n\tturnsRemaining;\r\n\toutcome;\r\n\tgameLog;\r\n\tdebugBoard;\r\n\r\n\tconstructor(rows, cols, winSequence) {\r\n\t\t//error handling\r\n\t\tif (rows <= MIN_SIZE || cols <= MIN_SIZE) throw new Error(\"BoardTooSmall\");\r\n\r\n\t\tif (rows > MAX_SIZE || cols > MAX_SIZE) throw new Error(\"BoardTooLarge\");\r\n\r\n\t\tif (winSequence > rows || winSequence > cols) throw new Error(\"WinSequenceTooLong\");\r\n\r\n\t\tif (winSequence <= 1) throw new Error(\"WinSequenceTooShort\");\r\n\r\n\t\tthis.rows = rows;\r\n\t\tthis.cols = cols;\r\n\t\tthis.winSequence = winSequence;\r\n\r\n\t\t//these attributes may change following subsequent games on the same board\r\n\t\tthis.reset();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new board with an identical context.\r\n\t */\r\n\tclone() {\r\n\t\tvar newGame = new Board(this.rows, this.cols, this.winSequence);\r\n\r\n\t\tnewGame.whiteMoves = this.whiteMoves;\r\n\t\tnewGame.totalMoves = this.totalMoves;\r\n\t\tnewGame.turnsRemaining = this.turnsRemaining;\r\n\t\tnewGame.gameLog = this.gameLog.slice();\r\n\t\tnewGame.outcome = this.outcome;\r\n\r\n\t\t//clone the board itself\r\n\t\tnewGame.board = new Array(this.rows);\r\n\t\tfor (let r = 0; r < this.rows; r++) {\r\n\t\t\tnewGame.board[r] = new Array(this.cols);\r\n\t\t\tfor (let c = 0; c < this.cols; c++) newGame.board[r][c] = this.board[r][c];\r\n\t\t}\r\n\r\n\t\treturn newGame;\r\n\t}\r\n\r\n\t/**\r\n\t * Resets the board to an initial position (without changing its size and other properties defined when the object was created)\r\n\t */\r\n\treset() {\r\n\t\tthis.totalMoves = 0;\r\n\t\tthis.whiteMoves = true;\r\n\t\tthis.turnsRemaining = this.cols * this.rows;\r\n\t\tthis.outcome = ONGOING;\r\n\t\tthis.gameLog = new Array();\r\n\r\n\t\tthis.board = new Array(this.rows);\r\n\r\n\t\tfor (let r = 0; r < this.rows; r++) {\r\n\t\t\tthis.board[r] = new Array(this.cols);\r\n\t\t\tfor (let c = 0; c < this.cols; c++) this.board[r][c] = EMPTY;\r\n\t\t}\r\n\t}\r\n\r\n\tdisplay() {\r\n\t\tvar output;\r\n\r\n\t\tfor (let r = this.rows - 1; r >= -1; r--) {\r\n\t\t\tfor (let c = 0; c < this.cols; c++) {\r\n\t\t\t\tif (r === -1) {\r\n\t\t\t\t\toutput += ` ${c} `;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet outputChar;\r\n\t\t\t\t\tswitch (this.board[r][c]) {\r\n\t\t\t\t\t\tcase EMPTY:\r\n\t\t\t\t\t\t\toutputChar = \"-\";\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase WHITE:\r\n\t\t\t\t\t\t\toutputChar = \"x\";\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase BLACK:\r\n\t\t\t\t\t\t\toutputChar = \"o\";\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tconsole.assert(true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\toutput += ` ${outputChar} `;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\toutput += \"\\n\";\r\n\t\t}\r\n\r\n\t\treturn output;\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {boolean} sideWhite Which side's remaining turns should be returned.\r\n\t */\r\n\tgetTurnsRemaining(sideWhite) {\r\n\t\tif (sideWhite) {\r\n\t\t\t//requested for white\r\n\t\t\tif (this.whiteMoves) {\r\n\t\t\t\treturn Math.ceil(this.turnsRemaining / 2);\r\n\t\t\t} //black moves\r\n\t\t\telse {\r\n\t\t\t\treturn Math.floor(this.turnsRemaining / 2);\r\n\t\t\t}\r\n\t\t} // requetsed for black\r\n\t\telse {\r\n\t\t\tif (!this.whiteMoves) {\r\n\t\t\t\treturn Math.ceil(this.turnsRemaining / 2);\r\n\t\t\t} //white moves\r\n\t\t\telse {\r\n\t\t\t\treturn Math.floor(this.turnsRemaining / 2);\r\n\t\t\t}\r\n\t\t}\r\n\t\tconsole.assert(true);\r\n\t}\r\n\r\n\t/**\r\n\t * Max number of sequences possible on this board size\r\n\t */\r\n\tgetMaxSequences() {\r\n\t\tvar count = (this.cols - this.winSequence + 1) * this.rows; //horizontals\r\n\r\n\t\tcount += (this.rows - this.winSequence + 1) * this.cols; //verticals\r\n\r\n\t\tcount += 2 * (this.cols - this.winSequence + 1) * (this.rows - this.winSequence + 1); //diagnoals\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\t// Returns how many partial rows of seqLength length the requested side has which currently are, or can potentially be extended to winSequence length.\r\n\tfindSeqInRow(sideWhite, seqLength) {\r\n\t\tconsole.assert(seqLength <= this.winSequence && seqLength > 0);\r\n\r\n\t\tvar row = 0;\r\n\t\tvar count = 0;\r\n\r\n\t\t// Go over each row\r\n\t\twhile (row < this.rows) {\r\n\t\t\t// Go over each sequence of winSequence cells (with overlaps)\r\n\t\t\tfor (let col = 0; col <= this.cols - this.winSequence; col++) {\r\n\t\t\t\t// count the total value in this subsequence\r\n\t\t\t\tlet sum = 0;\r\n\t\t\t\tlet emptyCells = 0;\r\n\t\t\t\tfor (let i = col; i < col + this.winSequence; i++) {\r\n\t\t\t\t\tlet thisCell = this.board[row][i];\r\n\t\t\t\t\tsum += thisCell;\r\n\t\t\t\t\tif (thisCell === EMPTY) emptyCells++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (sum === seqLength * (sideWhite ? WHITE : BLACK))\r\n\t\t\t\t\tif (this.getTurnsRemaining(sideWhite) >= emptyCells)\r\n\t\t\t\t\t\t// only count this if the requested side has enough moves remaining to theoretically occupy this sequence\r\n\t\t\t\t\t\tcount++;\r\n\t\t\t}\r\n\r\n\t\t\trow++;\r\n\t\t}\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\tfindSeqInCol(sideWhite, seqLength) {\r\n\t\tconsole.assert(seqLength <= this.winSequence && seqLength > 0);\r\n\r\n\t\tvar col = 0;\r\n\t\tvar count = 0;\r\n\r\n\t\t// Go over each col\r\n\t\twhile (col < this.cols) {\r\n\t\t\t// Go over each sequence of winSequence cells (with overlaps)\r\n\t\t\tfor (let row = 0; row <= this.rows - this.winSequence; row++) {\r\n\t\t\t\t// count the total value in this subsequence\r\n\t\t\t\tlet sum = 0;\r\n\t\t\t\tlet emptyCells = 0;\r\n\t\t\t\tfor (let i = row; i < row + this.winSequence; i++) {\r\n\t\t\t\t\tlet thisCell = this.board[i][col];\r\n\t\t\t\t\tsum += thisCell;\r\n\t\t\t\t\tif (thisCell === EMPTY) emptyCells++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (sum === seqLength * (sideWhite ? WHITE : BLACK))\r\n\t\t\t\t\tif (this.getTurnsRemaining(sideWhite) >= emptyCells)\r\n\t\t\t\t\t\t// only count this if the requested side has enough moves remaining to theoretically occupy this sequence\r\n\t\t\t\t\t\tcount++;\r\n\t\t\t}\r\n\r\n\t\t\tcol++;\r\n\t\t}\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\tfindSeqInDiag(sideWhite, seqLength) {\r\n\t\tconsole.assert(seqLength <= this.winSequence && seqLength > 0);\r\n\r\n\t\tvar count = 0;\r\n\r\n\t\t// Start with the diagonals where col increases as row decreases\r\n\t\tfor (let col = 0; col <= this.cols - this.winSequence; col++) {\r\n\t\t\t// Go over each sequence of winSequence cells (with overlaps)\r\n\t\t\tfor (let row = this.rows - 1; row >= this.winSequence - 1; row--) {\r\n\t\t\t\t// count the total value in this subsequence\r\n\t\t\t\tlet sum = 0;\r\n\t\t\t\tlet emptyCells = 0;\r\n\t\t\t\tfor (let i = 0; i < this.winSequence; i++) {\r\n\t\t\t\t\tlet thisCell = this.board[row - i][col + i];\r\n\t\t\t\t\tsum += thisCell;\r\n\t\t\t\t\tif (thisCell === EMPTY) emptyCells++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (sum === seqLength * (sideWhite ? WHITE : BLACK))\r\n\t\t\t\t\tif (this.getTurnsRemaining(sideWhite) >= emptyCells)\r\n\t\t\t\t\t\t// only count this if the requested side has enough moves remaining to theoretically occupy this sequence\r\n\t\t\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Analyze the diagonals where col increases as row increases\r\n\t\tfor (let col = 0; col <= this.cols - this.winSequence; col++) {\r\n\t\t\t// Go over each sequence of winSequence cells (with overlaps)\r\n\t\t\tfor (let row = 0; row <= this.rows - this.winSequence; row++) {\r\n\t\t\t\t// count the total value in this subsequence\r\n\t\t\t\tlet sum = 0;\r\n\t\t\t\tlet emptyCells = 0;\r\n\t\t\t\tfor (let i = 0; i < this.winSequence; i++) {\r\n\t\t\t\t\tlet thisCell = this.board[row + i][col + i];\r\n\t\t\t\t\tsum += thisCell;\r\n\t\t\t\t\tif (thisCell === EMPTY) emptyCells++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (sum === seqLength * (sideWhite ? WHITE : BLACK))\r\n\t\t\t\t\tif (this.getTurnsRemaining(sideWhite) >= emptyCells)\r\n\t\t\t\t\t\t// only count this if the requested side has enough moves remaining to theoretically occupy this sequence\r\n\t\t\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\r\n\tfindAllSeq(sideWhite, seqLength) {\r\n\t\treturn (\r\n\t\t\tthis.findSeqInRow(sideWhite, seqLength) +\r\n\t\t\tthis.findSeqInCol(sideWhite, seqLength) +\r\n\t\t\tthis.findSeqInDiag(sideWhite, seqLength)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the game's outcome:\r\n\t * WHITE_WIN - white won\r\n\t * BLACK_WIN - black won\r\n\t * DRAW - draw\r\n\t * ONGOING - game not over\r\n\t */\r\n\tgetOutcome() {\r\n\t\tif (this.findAllSeq(!this.whiteMoves, this.winSequence) > 0) return this.whiteMoves ? BLACK_WIN : WHITE_WIN;\r\n\r\n\t\tif (this.turnsRemaining === 0) return DRAW;\r\n\r\n\t\treturn ONGOING;\r\n\t}\r\n\r\n\t// Returns an array of all legal moves (by column numbers), or null if none.\r\n\tgetLegalMoves() {\r\n\t\tif (this.outcome !== ONGOING) return null;\r\n\r\n\t\tvar movesList = new Array();\r\n\r\n\t\tfor (let c = 0; c < this.cols; c++) {\r\n\t\t\tif (this.board[this.rows - 1][c] === EMPTY) {\r\n\t\t\t\tmovesList.push(c);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn movesList;\r\n\t}\r\n\r\n\t// If moves succeeds - returns row\r\n\t// If move cannot be done, returns null.\r\n\tmove(column) {\r\n\t\tif (column < 0 || column >= this.cols) return null;\r\n\r\n\t\tif (this.outcome !== ONGOING) return null;\r\n\r\n\t\tfor (let r = 0; r < this.rows; r++) {\r\n\t\t\tif (this.board[r][column] === EMPTY) {\r\n\t\t\t\tthis.board[r][column] = this.whiteMoves ? WHITE : BLACK;\r\n\r\n\t\t\t\tthis.gameLog.push({\r\n\t\t\t\t\tside: this.whiteMoves ? \"White\" : \"Black\",\r\n\t\t\t\t\trow: r,\r\n\t\t\t\t\tcol: parseInt(column, 10),\r\n\t\t\t\t}); //add move to game log\r\n\r\n\t\t\t\tthis.whiteMoves = !this.whiteMoves;\r\n\t\t\t\tthis.totalMoves++;\r\n\t\t\t\tthis.turnsRemaining--;\r\n\r\n\t\t\t\tthis.outcome = this.getOutcome();\r\n\r\n\t\t\t\tthis.debugBoard = this.display();\r\n\r\n\t\t\t\treturn r;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * Takes back the last move played and returns true if succeeded\r\n\t */\r\n\ttakeback() {\r\n\t\tif (this.totalMoves > 0) {\r\n\t\t\tconsole.assert(this.gameLog.length > 0);\r\n\t\t\tvar lastMove = this.gameLog.pop(); //pop the last move from the log\r\n\t\t\tvar lastRow = lastMove.row;\r\n\t\t\tvar lastCol = lastMove.col;\r\n\r\n\t\t\tconsole.assert(this.board[lastRow][lastCol] !== EMPTY);\r\n\r\n\t\t\tthis.board[lastRow][lastCol] = EMPTY; //turn last cell back to EMPTY state\r\n\t\t\tthis.whiteMoves = !this.whiteMoves; //change side\r\n\t\t\tthis.totalMoves--;\r\n\t\t\tthis.turnsRemaining++;\r\n\t\t\tthis.outcome = ONGOING; //if the game was over before the last move, it would not be possible to get here\r\n\t\t\tthis.debugBoard = this.display();\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets a location of a cell, and returns values denoting the count of the neighbors: total, whites, blacks, empties.\r\n\t */\r\n\tgetNeighbors(row, col) {\r\n\t\tvar empties = 0;\r\n\t\tvar whites = 0;\r\n\t\tvar blacks = 0;\r\n\r\n\t\tconsole.assert(col >= 0 && row >= 0 && col <= this.cols && row <= this.rows);\r\n\r\n\t\tfor (let r = Math.max(row - 1, 0); r <= Math.min(row + 1, this.rows - 1); r++) {\r\n\t\t\tfor (let c = Math.max(col - 1, 0); c <= Math.min(col + 1, this.cols - 1); c++) {\r\n\t\t\t\tif (r === row && c === col) continue;\r\n\r\n\t\t\t\tswitch (this.board[r][c]) {\r\n\t\t\t\t\tcase WHITE:\r\n\t\t\t\t\t\twhites++;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase BLACK:\r\n\t\t\t\t\t\tblacks++;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tempties++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn { whites, blacks, empties };\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a value denoting whose board position is stronger (white/black).\r\n\t * A higher positive number is better for white. A lower negative number is better for black.\r\n\t *\r\n\t * BLACK_WIN = black wins\r\n\t * 0 = balanced position or draw.\r\n\t * WHITE_WIN = white wins\r\n\t */\r\n\tassessment() {\r\n\t\t// return a quick result if it's game over\r\n\t\tif (this.outcome !== ONGOING) return this.outcome;\r\n\r\n\t\tvar remainingWhite = this.getTurnsRemaining(true);\r\n\t\tvar remainingBlack = this.getTurnsRemaining(false);\r\n\t\tvar whitePoints = 0;\r\n\t\tvar blackPoints = 0;\r\n\r\n\t\tfor (let r = 0; r < this.rows; r++)\r\n\t\t\tfor (let c = 0; c < this.cols; c++) {\r\n\t\t\t\tlet { whites, blacks } = this.getNeighbors(r, c);\r\n\t\t\t\tlet points = 0;\r\n\r\n\t\t\t\tif (r < this.rows / 2) points += r;\r\n\t\t\t\telse points += this.rows - r;\r\n\r\n\t\t\t\tif (c < this.cols / 2) points += c;\r\n\t\t\t\telse points += this.cols - c;\r\n\r\n\t\t\t\tif (this.board[r][c] === WHITE) {\r\n\t\t\t\t\twhitePoints += points + whites - blacks;\r\n\t\t\t\t} else if (this.board[r][c] === BLACK) {\r\n\t\t\t\t\tblackPoints += points + blacks - whites;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t// adjust the advantage based on who has more turns to go\r\n\t\tlet advantageFactor = 1 / this.turnsRemaining;\r\n\r\n\t\tif (remainingBlack > remainingWhite) blackPoints *= 1 + advantageFactor;\r\n\t\telse if (remainingWhite > remainingBlack) whitePoints *= 1 + advantageFactor;\r\n\t\t//same number of moves remaining\r\n\t\telse {\r\n\t\t\t// give a slight first-movers advantage\r\n\t\t\tif (this.whiteMoves) whitePoints *= 1 + advantageFactor / 3;\r\n\t\t\telse blackPoints *= 1 + advantageFactor / 3;\r\n\t\t}\r\n\r\n\t\t// go through all sequences of length 2 until (but lower than) winSequence\r\n\t\tfor (let i = this.winSequence - 1; i >= 2; i--) {\r\n\t\t\twhitePoints += Math.pow(this.findAllSeq(true, i), 3);\r\n\t\t\tblackPoints += Math.pow(this.findAllSeq(false, i), 3);\r\n\t\t}\r\n\r\n\t\treturn whitePoints - blackPoints;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns what it thinks is the best move for the currently playing side using ply number of recursive assessments, as well as the assessment of this position.\r\n\t * If the game is already over, returns null as the best move.\r\n\t *\r\n\t * @param {*} ply 0 will return an assessment of the current sitaution without looking ahead\r\n\t * @param {*} first pass true if calling to this function externally (as opposed to recursive calls) - for diagnostics only\r\n\t * @param {x} computerLevel a value from 0 to 1 denoting the quality of play/randomness (0 = lowest, 1 = highest)\r\n\t */\r\n\tplay(ply, first, computerLevel) {\r\n\t\tvar bestMove = null;\r\n\t\tvar assessment;\r\n\r\n\t\tif (first && this.outcome === ONGOING) {\r\n\t\t\t// on first call, test whether to intentionally reduce play quality\r\n\t\t\tif (computerLevel < Math.sqrt(Math.random())) {\r\n\t\t\t\t//intentionally degrading move quality at computerLevel% chance\r\n\t\t\t\tlet rand = Math.sqrt(Math.random());\r\n\t\t\t\t// at lower computerlevels, incline to reduce quality by reducing ply\r\n\t\t\t\tif (computerLevel >= rand) {\r\n\t\t\t\t\tply = Math.ceil(ply * rand);\r\n\t\t\t\t} //otherwise, reduce level through random moves (to introduce some variety)\r\n\t\t\t\telse {\r\n\t\t\t\t\tlet legalMoves = this.getLegalMoves();\r\n\t\t\t\t\tbestMove = legalMoves[Math.floor(Math.random() * legalMoves.length)];\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tadvisedMove: legalMoves[Math.floor(Math.random() * legalMoves.length)],\r\n\t\t\t\t\t\tbestAssessment: 0,\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Play strongest from this point:\r\n\t\tif (this.totalMoves === 0) {\r\n\t\t\t// always start in the middle\r\n\t\t\tbestMove = this.cols >> 1;\r\n\t\t\tassessment = 0;\r\n\t\t} else if (ply === 0) {\r\n\t\t\tassessment = this.assessment();\r\n\t\t} else if (this.outcome !== ONGOING) {\r\n\t\t\tassessment = this.outcome;\r\n\r\n\t\t\tif (assessment === WHITE_WIN) assessment += ply;\r\n\t\t\telse if (assessment === BLACK_WIN) assessment -= ply;\r\n\t\t} //game ongoing and ply >= 1\r\n\t\telse {\r\n\t\t\tlet legalMoves = this.getLegalMoves();\r\n\t\t\tassessment = this.whiteMoves ? BLACK_WIN - ply : WHITE_WIN + ply;\r\n\r\n\t\t\tfor (const move of legalMoves) {\r\n\t\t\t\tlet tempBoard = this.clone();\r\n\t\t\t\ttempBoard.move(move);\r\n\t\t\t\tconst advisedPlay = tempBoard.play(ply - 1, false, null);\r\n\r\n\t\t\t\tif (this.whiteMoves) {\r\n\t\t\t\t\tif (advisedPlay.bestAssessment > assessment) {\r\n\t\t\t\t\t\tbestMove = move;\r\n\t\t\t\t\t\tassessment = advisedPlay.bestAssessment;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if (assessment >= WHITE_WIN) //save time as optimal move already found\r\n\t\t\t\t\t// break;\r\n\t\t\t\t} // black\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (advisedPlay.bestAssessment < assessment) {\r\n\t\t\t\t\t\tbestMove = move;\r\n\t\t\t\t\t\tassessment = advisedPlay.bestAssessment;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if (assessment <= BLACK_WIN) //save time as optimal move already found\r\n\t\t\t\t\t//     break;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// no best move found - pick one at random\r\n\t\t\tif (bestMove === null) {\r\n\t\t\t\tbestMove = legalMoves[Math.floor(Math.random() * legalMoves.length)];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn { advisedMove: bestMove, bestAssessment: assessment };\r\n\t} //play\r\n}\r\n\r\n//// ******************* React Front-end ******************************************\r\n\r\nconst COMPUTER_WHITE = false;\r\nconst COMPUTER_MAX_POSITIONS = 12000;\r\nconst WHITE_TOKEN = \"⚪\";\r\nconst BLACK_TOKEN = \"⚫\";\r\nconst RESTART_GAME = 1;\r\nconst TAKEBACK = 2;\r\nconst PLAY_COMPUTER = 3;\r\nconst RESIZE_BOARD = 4;\r\nconst MIN_ROWS = 4;\r\nconst MAX_ROWS = 12;\r\nconst MIN_COLS = 4;\r\nconst MAX_COLS = 12;\r\nconst MIN_SEQ = 3;\r\nconst MAX_SEQ = 8;\r\n\r\nfunction Square(props) {\r\n\treturn (\r\n\t\t<button className=\"square\" onClick={props.onClick}>\r\n\t\t\t{props.value}\r\n\t\t</button>\r\n\t);\r\n}\r\n\r\nclass ReactBoard extends React.Component {\r\n\trenderSquare(r, c) {\r\n\t\treturn <Square value={this.props.squares[r][c]} onClick={() => this.props.onClick(r, c)} />;\r\n\t}\r\n\r\n\trender() {\r\n\t\tvar rowNum = gameRows;\r\n\t\tvar columnNum = gameColumns;\r\n\r\n\t\tconst rows = new Array(rowNum).fill();\r\n\t\tconst columns = new Array(columnNum).fill();\r\n\r\n\t\treturn (\r\n\t\t\t<div>\r\n\t\t\t\t{rows.map((el, rowIndex) => {\r\n\t\t\t\t\treturn (\r\n\t\t\t\t\t\t<div className=\"board-row\">\r\n\t\t\t\t\t\t\t{columns.map((el, colIndex) => this.renderSquare(rowNum - rowIndex - 1, colIndex))}\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t);\r\n\t\t\t\t})}\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n}\r\n\r\nclass ReactGame extends React.Component {\r\n\tgame;\r\n\tgamePly;\r\n\tcomputerWhite;\r\n\tlastRow;\r\n\tlastCol;\r\n\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.state = { squares: null };\r\n\t\tthis.computerWhite = COMPUTER_WHITE;\r\n\t\tthis.resetState();\r\n\t}\r\n\r\n\tresetState() {\r\n\t\tthis.lastRow = null;\r\n\t\tthis.lastCol = null;\r\n\t\tthis.game = new Board(gameRows, gameColumns, gameSeq);\r\n\r\n\t\t// how many moves to search ahead based on the max number of positions defined (speed trade-off)\r\n\t\tthis.gamePly = Math.floor((2 * Math.log(COMPUTER_MAX_POSITIONS)) / Math.log(gameRows * gameColumns));\r\n\r\n\t\tvar firstMove = null;\r\n\r\n\t\tif (this.computerWhite) {\r\n\t\t\tfirstMove = this.game.play(this.gamePly, true, computerLevel).advisedMove;\r\n\t\t\tthis.game.move(firstMove);\r\n\t\t}\r\n\r\n\t\tvar board = new Array(gameRows);\r\n\t\tfor (let r = 0; r < gameRows; r++) {\r\n\t\t\tboard[r] = new Array(gameColumns);\r\n\t\t\tfor (let c = 0; c < board[r].length; c++) board[r][c] = null;\r\n\t\t}\r\n\r\n\t\tif (this.computerWhite) {\r\n\t\t\tconsole.assert(firstMove != null);\r\n\t\t\tboard[0][firstMove] = WHITE_TOKEN;\r\n\t\t}\r\n\r\n\t\tthis.state.squares = board;\r\n\t}\r\n\r\n\thandleClick(r, c) {\r\n\t\tvar board = this.state.squares;\r\n\r\n\t\tif (this.game.outcome !== ONGOING) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet row = this.game.move(c);\r\n\t\tif (row == null) {\r\n\t\t\t//invalid move\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Human plays\r\n\t\tboard[row][c] = this.computerWhite ? BLACK_TOKEN : WHITE_TOKEN;\r\n\r\n\t\t// Computer plays\r\n\t\tlet computerMove = this.game.play(this.gamePly, true, computerLevel).advisedMove;\r\n\t\tif (computerMove != null) {\r\n\t\t\trow = this.game.move(computerMove);\r\n\t\t\tboard[row][computerMove] = this.computerWhite ? WHITE_TOKEN : BLACK_TOKEN;\r\n\t\t\t}\r\n\r\n\t\tthis.setState({\r\n\t\t\tsquares: board,\r\n\t\t});\r\n\t}\r\n\r\n\tjumpTo(actionType) {\r\n\t\tswitch (actionType) {\r\n\t\t\tcase RESTART_GAME:\r\n\t\t\t\tthis.resetState();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase TAKEBACK:\r\n\t\t\t\tif (this.game.totalMoves > 0) {\r\n\t\t\t\t\tconst lastMove = this.game.gameLog[this.game.gameLog.length - 1];\r\n\t\t\t\t\tconst lastRow = lastMove.row;\r\n\t\t\t\t\tconst lastCol = lastMove.col;\r\n\t\t\t\t\tthis.game.takeback();\r\n\t\t\t\t\tthis.state.squares[lastRow][lastCol] = null;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase PLAY_COMPUTER:\r\n\t\t\t\tlet computerMove = this.game.play(this.gamePly, true).advisedMove;\r\n\t\t\t\tif (computerMove != null) {\r\n\t\t\t\t\t//if a move is possible (game not over yet)\r\n\t\t\t\t\tlet row = this.game.move(computerMove);\r\n\t\t\t\t\tthis.computerWhite = !this.game.whiteMoves;\r\n\t\t\t\t\tthis.state.squares[row][computerMove] = this.computerWhite ? WHITE_TOKEN : BLACK_TOKEN;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase RESIZE_BOARD:\r\n\t\t\t\tlet error = true;\r\n\t\t\t\tvar newSize = prompt(\r\n\t\t\t\t\t`Enter a new board size and winning sequence (rows x columns x seq) from ${MIN_ROWS}x${MIN_COLS}x${MIN_SEQ} to ${MAX_ROWS}x${MAX_COLS}x${MAX_SEQ}:`,\r\n\t\t\t\t\t\"6x7x4\"\r\n\t\t\t\t);\r\n\t\t\t\tif (newSize !== null) {\r\n\t\t\t\t\tlet splitSize = newSize.split(`x`).map((x) => +x);\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tsplitSize.length === 3 &&\r\n\t\t\t\t\t\t!Number.isNaN(splitSize[0]) &&\r\n\t\t\t\t\t\t!Number.isNaN(splitSize[1]) &&\r\n\t\t\t\t\t\t!Number.isNaN(splitSize[2]) &&\r\n\t\t\t\t\t\tsplitSize[0] >= MIN_ROWS &&\r\n\t\t\t\t\t\tsplitSize[0] <= MAX_ROWS &&\r\n\t\t\t\t\t\tsplitSize[1] >= MIN_COLS &&\r\n\t\t\t\t\t\tsplitSize[1] <= MAX_COLS &&\r\n\t\t\t\t\t\tsplitSize[2] >= MIN_SEQ &&\r\n\t\t\t\t\t\tsplitSize[2] <= MAX_SEQ &&\r\n\t\t\t\t\t\tsplitSize[2] <= splitSize[0] &&\r\n\t\t\t\t\t\tsplitSize[2] <= splitSize[1]\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tgameRows = splitSize[0];\r\n\t\t\t\t\t\tgameColumns = splitSize[1];\r\n\t\t\t\t\t\tgameSeq = splitSize[2];\r\n\t\t\t\t\t\terror = false;\r\n\t\t\t\t\t\tthis.resetState();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (error) alert(\"Sorry, there was a problem with the size you entered. No changes made.\");\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tthis.setState({\r\n\t\t\tsquares: this.state.squares,\r\n\t\t});\r\n\t}\r\n\r\n\trender() {\r\n\t\tlet status = \"Game over: \";\r\n\r\n\t\t// If game is over with a win:\r\n\t\tif (this.game.outcome === WHITE_WIN || this.game.outcome === BLACK_WIN) {\r\n\t\t\tlet winningToken = this.game.outcome === WHITE_WIN ? WHITE_TOKEN : BLACK_TOKEN;\r\n\t\t\tif (this.computerWhite != null) {\r\n\t\t\t\t// if computer played\r\n\t\t\t\tif (this.computerWhite === this.game.whiteMoves) {\r\n\t\t\t\t\tstatus += `you ${winningToken} win!`;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstatus += `computer ${winningToken} wins!`;\r\n\t\t\t\t}\r\n\t\t\t} else status += `${winningToken} player wins!`;\r\n\t\t} else if (this.game.outcome === DRAW) {\r\n\t\t\tstatus += \"DRAW!\";\r\n\t\t} // ongoing game\r\n\t\telse status = \"You play \" + (this.game.whiteMoves ? WHITE_TOKEN : BLACK_TOKEN);\r\n\r\n\t\treturn (\r\n\t\t\t<div className=\"game\">\r\n\t\t\t\t<div className=\"game-board\">\r\n\t\t\t\t\t<ReactBoard squares={this.state.squares} onClick={(r, c) => this.handleClick(r, c)} />\r\n\t\t\t\t</div>\r\n\t\t\t\t<div className=\"game-info\">\r\n\t\t\t\t\t<div>Drop your tokens to form any line of {this.game.winSequence}!</div>\r\n\t\t\t\t\t<br></br>\r\n\t\t\t\t\t<div>{status}</div>\r\n\t\t\t\t\t<div></div>\r\n\t\t\t\t\t<ol>\r\n\t\t\t\t\t\t<li>\r\n\t\t\t\t\t\t\t<button onClick={() => this.jumpTo(RESTART_GAME)}>{\"Restart game\"}</button>\r\n\t\t\t\t\t\t</li>\r\n\t\t\t\t\t\t<br></br>\r\n\t\t\t\t\t\t<li>\r\n\t\t\t\t\t\t\t<button onClick={() => this.jumpTo(TAKEBACK)}>{\"Take back\"}</button>\r\n\t\t\t\t\t\t</li>\r\n\t\t\t\t\t\t<br></br>\r\n\t\t\t\t\t\t<li>\r\n\t\t\t\t\t\t\t<button onClick={() => this.jumpTo(PLAY_COMPUTER)}>{\"Play computer\"}</button>\r\n\t\t\t\t\t\t</li>\r\n\t\t\t\t\t\t<br></br>\r\n\t\t\t\t\t\t<li>\r\n\t\t\t\t\t\t\t<button onClick={() => this.jumpTo(RESIZE_BOARD)}>{\"Resize board\"}</button>\r\n\t\t\t\t\t\t</li>\r\n\t\t\t\t\t</ol>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n}\r\n\r\n// ========================================\r\n\r\nvar slider = document.getElementById(\"myRange\");\r\nvar computerLevel = slider.value;\r\nvar gameColumns = DEFAULT_COLUMNS;\r\nvar gameRows = DEFAULT_ROWS;\r\nvar gameSeq = DEFAULT_SEQ;\r\n\r\nslider.oninput = function () {\r\n\tcomputerLevel = this.value;\r\n};\r\n\r\nReactDOM.render(<ReactGame />, document.getElementById(\"root\"));\r\n",{"ruleId":"13","severity":1,"message":"14","line":79,"column":18,"nodeType":"15","messageId":"16","endLine":79,"endColumn":29},{"ruleId":"17","severity":1,"message":"18","line":142,"column":3,"nodeType":"19","messageId":"20","endLine":142,"endColumn":24},{"ruleId":"13","severity":1,"message":"14","line":295,"column":19,"nodeType":"15","messageId":"16","endLine":295,"endColumn":30},{"ruleId":"21","severity":1,"message":"22","line":621,"column":3,"nodeType":"23","endLine":621,"endColumn":13},{"ruleId":"21","severity":1,"message":"22","line":664,"column":6,"nodeType":"23","endLine":664,"endColumn":33},{"ruleId":"21","severity":1,"message":"22","line":674,"column":6,"nodeType":"23","endLine":674,"endColumn":29},"no-array-constructor","The array literal notation [] is preferable.","NewExpression","preferLiteral","no-unreachable","Unreachable code.","ExpressionStatement","unreachableCode","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression"]